<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Poem Scroll Animation</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            /* Native smooth scrolling */
        }

        body {
            font-family: 'Noto Serif TC', 'Georgia', serif;
            background-color: #f5f5f5;
            color: #333;
            overflow-x: hidden;
        }

        .poem-container {
            position: relative;
            width: 100%;
        }

        .poem-section {
            position: relative;
            height: 100vh;
            width: 100%;
            overflow: hidden;
        }

        .fixed-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            padding-right: 10%;
        }

        .poem-display {
            position: absolute;
            right: 10%;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            max-height: 90vh;
            overflow: visible;
        }

        .poem-line {
            font-size: 1.6rem;
            line-height: 1.5;
            text-align: right;
            font-weight: 300;
            color: #222;
            padding: 0.3rem 0;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            white-space: nowrap;
            /* Prevent line wrapping */
            overflow: visible;
            /* Ensure text is not cut off */
            width: auto;
            /* Allow the width to adjust to content */
            max-width: none;
            /* Remove max-width constraint */
            letter-spacing: 0.1em;
        }

        /* Style for paragraph breaks */
        .poem-line.paragraph-break {
            height: 1.5rem;
            /* Space between paragraphs */
            padding: 0;
            margin: 0.5rem 0;
        }

        .instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-size: 1.2rem;
            text-align: center;
            opacity: 0.9;
            z-index: 100;
            max-width: 80%;
        }

        .instructions p {
            margin: 0.5rem 0;
        }

        .instructions .arrow {
            font-size: 2rem;
            margin-top: 1rem;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            20%,
            50%,
            80%,
            100% {
                transform: translateY(0);
            }

            40% {
                transform: translateY(-20px);
            }

            60% {
                transform: translateY(-10px);
            }
        }

        .poem-input-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 200;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            transition: all 0.3s ease;
        }

        .poem-input-container.collapsed {
            width: 40px;
            height: 40px;
            overflow: hidden;
            cursor: pointer;
        }

        .poem-input-container.collapsed textarea,
        .poem-input-container.collapsed button,
        .poem-input-container.collapsed label,
        .poem-input-container.collapsed .settings {
            display: none;
        }

        .toggle-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #555;
        }

        .poem-input-container.collapsed .toggle-button {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: block;
        }

        textarea {
            width: 100%;
            height: 150px;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Noto Serif TC', 'Georgia', serif;
            resize: vertical;
        }

        button {
            background-color: #4a4a4a;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #333;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        .settings {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }

        .settings label {
            display: flex;
            align-items: center;
            font-weight: normal;
            margin-bottom: 8px;
        }

        .settings input[type="number"] {
            width: 60px;
            padding: 4px;
            margin-left: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .page-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .page-navigation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .page-navigation button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .page-navigation button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .page-navigation button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Blinking animation for the next button */
        @keyframes blink-button {

            0%,
            100% {
                background-color: rgba(0, 0, 0, 0.6);
            }

            50% {
                background-color: rgba(0, 0, 0, 0.9);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            }
        }

        .page-navigation button.blinking {
            animation: blink-button 1.5s infinite;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .poem-line {
                font-size: 1.4rem;
                padding: 0.2rem 0;
            }

            .fixed-container {
                padding-right: 5%;
            }

            .poem-display {
                right: 5%;
            }

            .poem-input-container {
                max-width: 250px;
            }

            .instructions {
                font-size: 1rem;
                padding: 0.8rem 1.5rem;
            }
        }

        @media (max-width: 480px) {
            .poem-line {
                font-size: 1.2rem;
            }

            .poem-input-container {
                max-width: 200px;
            }

            .instructions {
                font-size: 0.9rem;
                padding: 0.7rem 1.2rem;
            }
        }
    </style>
</head>

<body>
    <div class="instructions">
        <p>向下滾動以顯示詜詞</p>
        <div class="arrow">↓</div>
    </div>

    <div class="poem-input-container collapsed">
        <button class="toggle-button">≡</button>
        <label for="poem-text">輸入詩詞（每行一句，空行表示段落分隔）：</label>
        <textarea id="poem-text">輕輕的我走了，
            正如我輕輕的來；
            我輕輕的招手，
            作別西天的雲彩。

            那河畔的金柳，
            是夕陽中的新娘；
            波光裡的艷影，
            在我的心頭蕩漾。

            軟泥上的青荇，
            油油的在水底招搖；
            在康橋的柔波裡，
            我甘心做一條水草！

            那榆蔭下的一潭，
            不是清泉，
            是天上虹 揉碎在浮藻間，
            沉澱著彩虹似的夢。

            尋夢？撐一支長蒿，
            向青草更青處漫溯，
            滿載一船星輝，
            在星輝斑斕裡放歌。

            但我不能放歌，
            悄悄是別離的笙簫；
            夏蟲也為我沉默，
            沉默是今晚的康橋！

            悄悄的我走了，
            正如我悄悄的來；
            我揮一揮衣袖，
            不帶走一片雲彩。</textarea>
        <div class="settings">
            <label>
                每頁顯示行數：
                <input type="number" id="lines-per-page" min="1" max="20" value="8">
            </label>
        </div>
        <button id="update-poem">更新詩詞</button>
    </div>

    <div class="poem-container">
        <!-- Poem sections will be added by JavaScript -->
    </div>

    <div class="fixed-container">
        <div class="poem-display">
            <!-- Poem lines will be added here -->
        </div>
    </div>

    <div class="page-indicator">第 <span id="current-page">1</span> 頁，共 <span id="total-pages">1</span> 頁</div>

    <div class="page-navigation">
        <button id="prev-page" disabled>&lt;</button>
        <button id="next-page">&gt;</button>
    </div>

    <!-- GSAP, ScrollTrigger, and Splitting.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollToPlugin.min.js"></script>
    <script src="https://unpkg.com/splitting/dist/splitting.min.js"></script>
    <link href="https://unpkg.com/splitting/dist/splitting.css" rel="stylesheet" />

    <script>
        // Register GSAP plugins
        gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

        // DOM elements
        const poemContainer = document.querySelector('.poem-container');
        const poemDisplay = document.querySelector('.poem-display');
        const instructions = document.querySelector('.instructions');
        const poemTextarea = document.getElementById('poem-text');
        const updateButton = document.getElementById('update-poem');
        const toggleButton = document.querySelector('.toggle-button');
        const inputContainer = document.querySelector('.poem-input-container');
        const linesPerPageInput = document.getElementById('lines-per-page');
        const pageIndicator = document.querySelector('.page-indicator');
        const currentPageSpan = document.getElementById('current-page');
        const totalPagesSpan = document.getElementById('total-pages');
        const prevPageButton = document.getElementById('prev-page');
        const nextPageButton = document.getElementById('next-page');

        // Toggle input container
        toggleButton.addEventListener('click', () => {
            inputContainer.classList.toggle('collapsed');
            toggleButton.textContent = inputContainer.classList.contains('collapsed') ? '≡' : '×';
        });

        // Variables
        let allPoemLines = []; // All poem lines
        let poemPages = []; // Array of pages, each containing an array of line objects
        let sections = [];
        let lineElements = [];
        let currentIndex = -1; // Start with -1 so no lines are shown initially
        let isScrolling = false;
        let scrollTriggers = [];
        let hasScrolled = false; // Track if user has scrolled
        let paragraphBreakIndices = []; // Track indices of paragraph breaks
        let currentPage = 0;
        let totalPages = 1;
        let linesPerPage = 8; // Default lines per page

        // Function to parse poem from textarea
        function getPoemLines() {
            const lines = poemTextarea.value.split('\n');
            const result = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // If this is an empty line and not the first or last line, add a paragraph break
                if (line === '' && i > 0 && i < lines.length - 1) {
                    result.push({ text: '', isParagraphBreak: true });
                }
                // Otherwise, if it's not an empty line at the beginning or end, add it as a regular line
                else if (line !== '' || (i > 0 && i < lines.length - 1)) {
                    result.push({ text: line, isParagraphBreak: false });
                }
            }

            return result;
        }

        // Function to divide poem lines into pages
        function createPoemPages(lines) {
            const pages = [];
            let currentPage = [];
            let lineCount = 0;

            // Get lines per page from input
            linesPerPage = parseInt(linesPerPageInput.value) || 8;

            // Ensure linesPerPage is within reasonable bounds
            linesPerPage = Math.max(1, Math.min(20, linesPerPage));

            lines.forEach(line => {
                // Add line to current page
                currentPage.push(line);

                // If not a paragraph break, increment line count
                if (!line.isParagraphBreak) {
                    lineCount++;
                }

                // If we've reached the max lines per page, start a new page
                if (lineCount >= linesPerPage) {
                    pages.push([...currentPage]);
                    currentPage = [];
                    lineCount = 0;
                }
            });

            // Add any remaining lines to the last page
            if (currentPage.length > 0) {
                pages.push(currentPage);
            }

            return pages;
        }

        // Function to clear existing poem
        function clearPoem() {
            // Remove all sections
            sections.forEach(section => {
                section.remove();
            });
            sections = [];

            // Remove all line elements
            lineElements.forEach(line => {
                line.remove();
            });
            lineElements = [];

            // Clear poem display
            poemDisplay.innerHTML = '';

            // Kill all scroll triggers
            scrollTriggers.forEach(trigger => {
                trigger.kill();
            });
            scrollTriggers = [];

            // Reset current index and scroll state
            currentIndex = -1;
            paragraphBreakIndices = [];

            // Don't reset hasScrolled or show instructions when navigating between pages
            if (!hasScrolled) {
                instructions.style.display = 'block';
                gsap.to(instructions, {
                    opacity: 0.9,
                    duration: 0.5
                });
            }

            // Hide page navigation
            gsap.to([pageIndicator, document.querySelector('.page-navigation')], {
                opacity: 0,
                duration: 0.3
            });
        }

        // Function to create poem elements for the current page
        function createPoemElements() {
            // Clear any existing elements
            poemDisplay.innerHTML = '';
            lineElements = [];
            sections = [];
            paragraphBreakIndices = [];

            // Get the current page of lines
            const pageLines = poemPages[currentPage];

            // Set container height based on number of sections
            poemContainer.style.height = `${pageLines.length * 100}vh`;

            // Create poem sections and line elements
            pageLines.forEach((line, index) => {
                // Create section for each line
                const section = document.createElement('div');
                section.classList.add('poem-section');
                section.id = `section-${index}`;
                section.dataset.index = index;
                poemContainer.appendChild(section);
                sections.push(section);

                // Create line element
                const lineElement = document.createElement('div');
                lineElement.classList.add('poem-line');
                if (line.isParagraphBreak) {
                    lineElement.classList.add('paragraph-break');
                    lineElement.innerHTML = '&nbsp;'; // Non-breaking space
                    paragraphBreakIndices.push(index); // Track paragraph break indices
                } else {
                    lineElement.textContent = line.text;
                }
                lineElement.id = `line-${index}`;
                poemDisplay.appendChild(lineElement);
                lineElements.push(lineElement);

                // Ensure all lines are initially hidden
                gsap.set(lineElement, {
                    opacity: 0,
                    y: 30
                });
            });

            // Update page indicator
            currentPageSpan.textContent = currentPage + 1;
            totalPagesSpan.textContent = totalPages;

            // Update navigation buttons
            prevPageButton.disabled = currentPage === 0;
            nextPageButton.disabled = currentPage === totalPages - 1;

            // Show page navigation if we have more than one page
            if (totalPages > 1) {
                gsap.to([pageIndicator, document.querySelector('.page-navigation')], {
                    opacity: 1,
                    duration: 0.3
                });
            } else {
                gsap.to([pageIndicator, document.querySelector('.page-navigation')], {
                    opacity: 0,
                    duration: 0.3
                });
            }
        }

        // Function to set up scroll triggers
        function setupScrollTriggers() {
            scrollTriggers = [];

            sections.forEach((section, index) => {
                const trigger = ScrollTrigger.create({
                    trigger: section,
                    start: "top center",
                    end: "bottom center",
                    markers: false,
                    onEnter: () => {
                        // First time user scrolls, hide instructions
                        if (!hasScrolled) {
                            hasScrolled = true;
                            gsap.to(instructions, {
                                opacity: 0,
                                duration: 0.5,
                                onComplete: () => {
                                    instructions.style.display = 'none';
                                }
                            });
                        }

                        if (currentIndex < index) {
                            currentIndex = index;
                            updateDisplay();

                            // If this is a paragraph break, automatically scroll to the next line
                            if (paragraphBreakIndices.includes(index) && index < sections.length - 1) {
                                setTimeout(() => {
                                    if (!isScrolling) {
                                        scrollToIndex(index + 1);
                                    }
                                }, 300); // Short delay before auto-scrolling
                            }
                        }
                    },
                    onLeaveBack: () => {
                        if (currentIndex >= index) {
                            currentIndex = index - 1;
                            updateDisplay();

                            // If scrolling back and the previous line is a paragraph break, skip it
                            if (paragraphBreakIndices.includes(currentIndex) && currentIndex > 0) {
                                setTimeout(() => {
                                    if (!isScrolling) {
                                        scrollToIndex(currentIndex - 1);
                                    }
                                }, 300);
                            }
                        }
                    }
                });

                scrollTriggers.push(trigger);
            });

            // Add snap scrolling
            const snapTrigger = ScrollTrigger.create({
                snap: sections.length > 1 ? {
                    snapTo: 1 / (sections.length - 1),
                    duration: 0.5,
                    delay: 0.1,
                    ease: "power2.inOut"
                } : null
            });

            scrollTriggers.push(snapTrigger);
        }

        // Function to scroll to a specific index
        function scrollToIndex(index) {
            if (index < 0 || index >= sections.length) return;

            isScrolling = true;

            gsap.to(window, {
                duration: 0.5, // Faster for auto-scrolling
                scrollTo: {
                    y: `#section-${index}`,
                    offsetY: 0
                },
                ease: "power2.inOut",
                onComplete: () => {
                    isScrolling = false;
                }
            });
        }

        // Function to navigate to a specific page
        function navigateToPage(pageIndex) {
            if (pageIndex < 0 || pageIndex >= totalPages) return;

            // Remove blinking from buttons when navigating
            nextPageButton.classList.remove('blinking');
            prevPageButton.classList.remove('blinking');

            // Update current page
            currentPage = pageIndex;

            // Clear current display
            clearPoem();

            // Create elements for the new page
            createPoemElements();

            // Adjust font sizes
            adjustLineFontSizes();

            // Hide instructions since we're showing content
            instructions.style.display = 'none';
            hasScrolled = true;

            // Set current index to show the first line
            currentIndex = 0;

            // IMPORTANT: Make sure the first line is visible before setting up scroll triggers
            // Find the first non-paragraph-break line
            let firstContentLineIndex = 0;
            for (let i = 0; i < lineElements.length; i++) {
                if (!lineElements[i].classList.contains('paragraph-break')) {
                    firstContentLineIndex = i;
                    break;
                }
            }

            // Make the first content line visible immediately
            lineElements.forEach((line, i) => {
                if (i === firstContentLineIndex) {
                    // Show first content line immediately with full opacity
                    gsap.set(line, {
                        opacity: 1,
                        y: 0
                    });
                    // Update currentIndex to this line
                    currentIndex = firstContentLineIndex;
                } else if (i < firstContentLineIndex && lineElements[i].classList.contains('paragraph-break')) {
                    // Show paragraph breaks before the first content line with reduced opacity
                    gsap.set(line, {
                        opacity: 0.3,
                        y: 0
                    });
                } else {
                    // Hide all other lines
                    gsap.set(line, {
                        opacity: 0,
                        y: 30
                    });
                }
            });

            // Now set up scroll triggers after ensuring first line visibility
            setupScrollTriggers();

            // Scroll to top
            window.scrollTo(0, 0);

            // Update page indicator
            currentPageSpan.textContent = currentPage + 1;

            // Update navigation buttons
            prevPageButton.disabled = currentPage === 0;
            nextPageButton.disabled = currentPage === totalPages - 1;
        }

        // Function to adjust font size for each line to fit in one line
        function adjustLineFontSizes() {
            const viewportWidth = window.innerWidth;
            const maxWidth = viewportWidth * 0.85; // 85% of viewport width

            lineElements.forEach(line => {
                // Skip paragraph breaks
                if (line.classList.contains('paragraph-break')) return;

                // Start with a reasonable font size
                let fontSize = 1.6;
                line.style.fontSize = `${fontSize}rem`;

                // Reduce font size until it fits
                while (line.getBoundingClientRect().width > maxWidth && fontSize > 0.6) {
                    fontSize -= 0.1;
                    line.style.fontSize = `${fontSize}rem`;
                }
            });
        }

        // Function to update the display based on current index
        function updateDisplay() {
            // Reset all lines
            lineElements.forEach((line, i) => {
                if (i <= currentIndex) {
                    // Show lines up to current index
                    gsap.to(line, {
                        opacity: line.classList.contains('paragraph-break') ? 0.3 : 1, // Lower opacity for paragraph breaks
                        y: 0,
                        duration: 0.5,
                        delay: i === currentIndex ? 0.1 : 0 // Slight delay for newest line
                    });
                } else {
                    // Hide lines after current index
                    gsap.to(line, {
                        opacity: 0,
                        y: 30,
                        duration: 0.3
                    });
                }
            });

            // Check if we've reached the last line of the page
            if (currentIndex === sections.length - 1 && currentPage < totalPages - 1) {
                // Make the next button blink
                nextPageButton.classList.add('blinking');
                // Stop blinking after 5 seconds
                setTimeout(() => {
                    nextPageButton.classList.remove('blinking');
                }, 5000);
            } else {
                // Remove blinking if not at the last line
                nextPageButton.classList.remove('blinking');
            }

            // Check if we're at the first line of the page
            if (currentIndex === 0 && currentPage > 0) {
                // Make the previous button blink
                prevPageButton.classList.add('blinking');
                // Stop blinking after 5 seconds
                setTimeout(() => {
                    prevPageButton.classList.remove('blinking');
                }, 5000);
            } else {
                // Remove blinking if not at the first line
                prevPageButton.classList.remove('blinking');
            }
        }

        // Function to initialize the poem
        function initializePoem() {
            // Parse all poem lines
            allPoemLines = getPoemLines();

            // Create pages
            poemPages = createPoemPages(allPoemLines);

            // Set total pages
            totalPages = poemPages.length;

            // Start with the first page
            currentPage = 0;

            // Clear any existing poem
            clearPoem();

            // Create elements for the first page
            createPoemElements();

            // Adjust font sizes
            adjustLineFontSizes();

            // Set up scroll triggers
            setupScrollTriggers();

            // Collapse the input container after updating
            inputContainer.classList.add('collapsed');
            toggleButton.textContent = '≡';

            // Scroll to top
            window.scrollTo(0, 0);
        }

        // Update button event listener
        updateButton.addEventListener('click', initializePoem);

        // Page navigation event listeners
        prevPageButton.addEventListener('click', () => {
            if (currentPage > 0) {
                navigateToPage(currentPage - 1);
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (currentPage < totalPages - 1) {
                navigateToPage(currentPage + 1);
            }
        });

        // Wheel event for better snap control
        window.addEventListener('wheel', function (e) {
            if (isScrolling || sections.length === 0) return;

            // First time user scrolls, hide instructions
            if (!hasScrolled && e.deltaY > 0) {
                hasScrolled = true;
                gsap.to(instructions, {
                    opacity: 0,
                    duration: 0.5,
                    onComplete: () => {
                        instructions.style.display = 'none';
                    }
                });
            }

            isScrolling = true;

            let targetIndex = currentIndex;

            if (e.deltaY > 0) {
                // Scrolling down
                if (targetIndex < sections.length - 1) {
                    targetIndex++;

                    // If target is a paragraph break, skip to the next line
                    if (paragraphBreakIndices.includes(targetIndex) && targetIndex < sections.length - 1) {
                        targetIndex++;
                    }
                } else {
                    // At the end of the page, don't allow further scrolling
                    // User must click the next button to go to the next page
                    isScrolling = false;

                    // Make the next button blink if there's a next page
                    if (currentPage < totalPages - 1) {
                        nextPageButton.classList.add('blinking');
                        // Stop blinking after 5 seconds
                        setTimeout(() => {
                            nextPageButton.classList.remove('blinking');
                        }, 5000);
                    }
                    return;
                }
            } else if (e.deltaY < 0) {
                // Scrolling up
                if (targetIndex > 0) {
                    targetIndex--;

                    // If target is a paragraph break, skip to the previous line
                    if (paragraphBreakIndices.includes(targetIndex) && targetIndex > 0) {
                        targetIndex--;
                    }
                } else {
                    // At the beginning of the page, don't allow further scrolling
                    // User must click the previous button to go to the previous page
                    isScrolling = false;

                    // Make the previous button blink if there's a previous page
                    if (currentPage > 0) {
                        prevPageButton.classList.add('blinking');
                        // Stop blinking after 5 seconds
                        setTimeout(() => {
                            prevPageButton.classList.remove('blinking');
                        }, 5000);
                    }
                    return;
                }
            } else {
                isScrolling = false;
                return;
            }

            scrollToIndex(targetIndex);

            e.preventDefault();
        }, { passive: false });

        // Touch events for mobile
        window.addEventListener('touchstart', function (e) {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', function (e) {
            if (isScrolling || sections.length === 0) return;

            const touchY = e.touches[0].clientY;
            const diff = touchStartY - touchY;

            // First time user scrolls, hide instructions
            if (!hasScrolled && diff > 0) {
                hasScrolled = true;
                gsap.to(instructions, {
                    opacity: 0,
                    duration: 0.5,
                    onComplete: () => {
                        instructions.style.display = 'none';
                    }
                });
            }

            if (Math.abs(diff) > 50) {
                isScrolling = true;

                let targetIndex = currentIndex;

                if (diff > 0) {
                    // Swipe up (scroll down)
                    if (targetIndex < sections.length - 1) {
                        targetIndex++;

                        // If target is a paragraph break, skip to the next line
                        if (paragraphBreakIndices.includes(targetIndex) && targetIndex < sections.length - 1) {
                            targetIndex++;
                        }
                    } else {
                        // At the end of the page, don't allow further scrolling
                        // User must click the next button to go to the next page
                        isScrolling = false;

                        // Make the next button blink if there's a next page
                        if (currentPage < totalPages - 1) {
                            nextPageButton.classList.add('blinking');
                            // Stop blinking after 5 seconds
                            setTimeout(() => {
                                nextPageButton.classList.remove('blinking');
                            }, 5000);
                        }
                        return;
                    }
                } else if (diff < 0) {
                    // Swipe down (scroll up)
                    if (targetIndex > 0) {
                        targetIndex--;

                        // If target is a paragraph break, skip to the previous line
                        if (paragraphBreakIndices.includes(targetIndex) && targetIndex > 0) {
                            targetIndex--;
                        }
                    } else {
                        // At the beginning of the page, don't allow further scrolling
                        // User must click the previous button to go to the previous page
                        isScrolling = false;

                        // Make the previous button blink if there's a previous page
                        if (currentPage > 0) {
                            prevPageButton.classList.add('blinking');
                            // Stop blinking after 5 seconds
                            setTimeout(() => {
                                prevPageButton.classList.remove('blinking');
                            }, 5000);
                        }
                        return;
                    }
                } else {
                    isScrolling = false;
                    return;
                }

                scrollToIndex(targetIndex);

                touchStartY = touchY;
            }
        }, { passive: true });

        // Adjust on resize
        window.addEventListener('resize', function () {
            adjustLineFontSizes();
        });

        // Initialize on load
        window.addEventListener('load', initializePoem);

        // Keyboard navigation
        window.addEventListener('keydown', function (e) {
            // Page navigation with arrow keys
            if (e.key === 'ArrowLeft' && currentPage > 0) {
                navigateToPage(currentPage - 1);
            } else if (e.key === 'ArrowRight' && currentPage < totalPages - 1) {
                navigateToPage(currentPage + 1);
            }

            // Line navigation with up/down arrow keys
            if (e.key === 'ArrowUp' && currentIndex > 0) {
                let targetIndex = currentIndex - 1;
                // Skip paragraph breaks
                if (paragraphBreakIndices.includes(targetIndex) && targetIndex > 0) {
                    targetIndex--;
                }
                scrollToIndex(targetIndex);
            } else if (e.key === 'ArrowDown' && currentIndex < sections.length - 1) {
                let targetIndex = currentIndex + 1;
                // Skip paragraph breaks
                if (paragraphBreakIndices.includes(targetIndex) && targetIndex < sections.length - 1) {
                    targetIndex++;
                }
                scrollToIndex(targetIndex);
            }
        });

        // Utility function to scroll to a specific index
        function scrollToIndex(index) {
            if (index < 0 || index >= sections.length) return;

            isScrolling = true;

            gsap.to(window, {
                duration: 0.5,
                scrollTo: {
                    y: `#section-${index}`,
                    offsetY: 0
                },
                ease: "power2.inOut",
                onComplete: () => {
                    isScrolling = false;
                }
            });
        }

        // Utility function to handle navigation logic
        function handleNavigation(direction) {
            let targetIndex = currentIndex;

            if (direction === 'down') {
                if (targetIndex < sections.length - 1) {
                    targetIndex++;
                    if (paragraphBreakIndices.includes(targetIndex) && targetIndex < sections.length - 1) {
                        targetIndex++;
                    }
                } else {
                    // At the end of the page, don't navigate automatically
                    return;
                }
            } else if (direction === 'up') {
                if (targetIndex > 0) {
                    targetIndex--;
                    if (paragraphBreakIndices.includes(targetIndex) && targetIndex > 0) {
                        targetIndex--;
                    }
                } else {
                    // At the beginning of the page, don't navigate automatically
                    return;
                }
            }

            scrollToIndex(targetIndex);
        }

        // Combined event handler for wheel and touchmove
        function handleScrollEvent(deltaY) {
            if (isScrolling || sections.length === 0) return;

            if (!hasScrolled && deltaY > 0) {
                hasScrolled = true;
                gsap.to(instructions, {
                    opacity: 0,
                    duration: 0.5,
                    onComplete: () => {
                        instructions.style.display = 'none';
                    }
                });
            }

            isScrolling = true;

            if (deltaY > 0) {
                handleNavigation('down');
            } else if (deltaY < 0) {
                handleNavigation('up');
            }

            setTimeout(() => {
                isScrolling = false;
            }, 500);
        }

        // Event listeners
        window.addEventListener('wheel', (e) => handleScrollEvent(e.deltaY), { passive: false });

        let touchStartY = 0;
        window.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            const touchY = e.touches[0].clientY;
            const diff = touchStartY - touchY;

            if (Math.abs(diff) > 50) {
                handleScrollEvent(diff);
                touchStartY = touchY;
            }
        }, { passive: true });
    </script>
</body>

</html>